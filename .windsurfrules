# AI Coding Assistant Rules for Yorizon Buddy V1.2

## Standard Universal Rules
### ðŸ”„ Project Awareness & Context
- **Always analyze the Initial Documents folder first**, especially:
  - `YorizonBuddy_Overview.txt`
  - `YorizonBuddy_Scope.txt`
  - `YorizonBuddy_ImplementationGuide.txt`
  - `YorizonBuddy_Dependencies.txt`
- **Thoroughly understand the project architecture, goals, and constraints** before starting any coding task.
- **Create a `TASK.md` file** if it doesn't exist to track tasks. When starting a new task, document it with a brief description and today's date.
- **Maintain consistent naming conventions, file structure, and architecture patterns** as specified in the implementation guide.
- **Be adaptable to project evolution** - if requirements change beyond the original scope, document these changes and integrate them coherently with the existing architecture.

### ðŸ§± Code Structure & Modularity
- **Never create a file longer than 500 lines of code.** If a file approaches this limit, refactor by splitting it into modules or helper files.
- **Organize code into clearly separated modules**, grouped by feature or responsibility.
- **Use clear, consistent imports** (prefer relative imports within packages).
- **When introducing new components**, follow the organizational patterns established in the codebase.

### ðŸ§ª Testing & Reliability
- **Create appropriate unit tests for new features** using the testing framework appropriate for the chosen language/stack.
- **After updating any logic**, check whether existing unit tests need to be updated. If so, do it.
- **Tests should live in a dedicated test directory** mirroring the main app structure.
  - Include at least:
    - 1 test for expected use
    - 1 edge case
    - 1 failure case

### âœ… Task Completion
- **Create or update `TASK.md`** to track completed tasks.
- **Mark completed tasks** immediately after finishing them.
- Add new sub-tasks or TODOs discovered during development under a "Discovered During Work" section.
- **Document any features added beyond the original scope** in a dedicated section labeled "Scope Extensions".

### ðŸ“Ž Style & Conventions
- **Follow the language-specific style guides** for the chosen technology stack:
  - For Python: PEP8, type hints, and format with `black`
  - For JavaScript/TypeScript: ESLint, Prettier, and appropriate framework conventions
  - For other languages: Follow industry-standard conventions
- **Write comprehensive docstrings/comments** for every function using the standard convention for the chosen language.
- **Adhere to the `YorizonBuddy_Designguideline.txt`** for UI/UX elements and general code organization.

## Project-Specific Rules

### ðŸ”§ Technology Stack Implementation
- **Use TypeScript with strict mode enabled** for all code (no `any` types unless absolutely necessary).
  ```typescript
  // Incorrect
  const handleClick = (event: any) => {
    console.log(event.value);
  };
  
  // Correct
  const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
    console.log((event.target as HTMLButtonElement).value);
  };
  ```

- **Create React components using functional style with hooks** (no class components).
  ```typescript
  // Correct approach
  const PromptEditor: React.FC<PromptEditorProps> = ({ initialValue, onSave }) => {
    const [content, setContent] = useState(initialValue);
    // Component logic...
    return (/* JSX */);
  };
  ```

- **Use React Context API for feature-scoped state** and Redux/Zustand only for global app state.
  ```typescript
  // Create context for each feature area
  export const VoiceRecordingContext = createContext<VoiceRecordingContextType | undefined>(undefined);
  
  export const VoiceRecordingProvider: React.FC<PropsWithChildren> = ({ children }) => {
    // State and handlers specific to voice recording
    return (
      <VoiceRecordingContext.Provider value={contextValue}>
        {children}
      </VoiceRecordingContext.Provider>
    );
  };
  ```

- **Implement Chrome Extension APIs with abstraction layers** to make future refactoring easier.
  ```typescript
  // Create service abstractions for Chrome APIs
  class StorageService {
    async get(key: string): Promise<any> {
      return new Promise((resolve) => {
        chrome.storage.local.get(key, (result) => {
          resolve(result[key]);
        });
      });
    }
    // Other methods...
  }
  
  // Use the service in components
  const { data } = useQuery(['settings'], () => storageService.get('settings'));
  ```

- **Use TailwindCSS for styling** with custom theme values defined in `tailwind.config.js`.
  ```typescript
  // Example component with Tailwind styling
  <div className="flex flex-col p-4 bg-primary-100 dark:bg-primary-900 rounded-lg shadow-sm">
    <h2 className="text-lg font-semibold text-gray-800 dark:text-white mb-2">
      {title}
    </h2>
    {/* Component content */}
  </div>
  ```

- **Implement React Query for data fetching and caching** to improve performance and user experience.
  ```typescript
  // Data fetching with React Query
  const { data, isLoading, error } = useQuery(
    ['agent-chat', agentId, conversationId],
    () => agentService.getConversation(agentId, conversationId),
    {
      staleTime: 60 * 1000, // 1 minute
      cacheTime: 30 * 60 * 1000, // 30 minutes
    }
  );
  ```

### ðŸ’¾ Database & API Structure
- **Use a repository pattern for all storage operations** to abstract the underlying technology.
  ```typescript
  // Repository interface 
  interface PromptsRepository {
    getAll(categoryId?: string): Promise<Prompt[]>;
    getById(id: string): Promise<Prompt | null>;
    save(prompt: Prompt): Promise<string>;
    delete(id: string): Promise<boolean>;
  }
  
  // Implementation for IndexedDB
  class IndexedDBPromptsRepository implements PromptsRepository {
    // Implementation details...
  }
  ```

- **Structure IndexedDB with these primary object stores**:
  - `prompts`: For prompt templates and categories
  - `automations`: For automation flow configurations
  - `agents`: For agent configurations
  - `conversations`: For agent chat history
  - `voiceRecordings`: For saved voice recordings
  - `settings`: For user preferences and configurations

- **Use versioned database schema** with clear migration paths for each version increment.
  ```typescript
  const db = new Dexie('YorizonBuddy');
  
  // Define schema with version
  db.version(1).stores({
    prompts: '++id, categoryId, title, *tags, createdAt, updatedAt',
    categories: '++id, name, parentId, type',
    // ...other stores
  });
  
  // Migration to version 2
  db.version(2).stores({
    prompts: '++id, categoryId, title, *tags, createdAt, updatedAt, isArchived',
    // ...with schema changes
  }).upgrade(tx => {
    // Perform migration logic
    return tx.prompts.toCollection().modify(prompt => {
      prompt.isArchived = false;
    });
  });
  ```

- **Implement caching for external API calls** with appropriate cache invalidation strategies.
  ```typescript
  const fetchWithCache = async (url: string, options: RequestInit, cacheDuration = 3600000) => {
    const cacheKey = `api-cache-${hashString(url + JSON.stringify(options.body || ''))}`;
    const cached = await storageService.get(cacheKey);
    
    if (cached && cached.timestamp > Date.now() - cacheDuration) {
      return cached.data;
    }
    
    const response = await fetch(url, options);
    const data = await response.json();
    
    await